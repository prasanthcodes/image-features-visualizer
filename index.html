<!DOCTYPE html>
<html lang="en">

<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0"> 
<title>image features</title>
<style>
body {
  font-family: "Lato", sans-serif;
}

.sidenav {
  height: 100%;
  width: 0;
  position: fixed;
  z-index: 1;
  top: 0;
  left: 0;
  background-color: #555555ee;
  overflow-x: hidden;
  transition: 0.5s;
  padding-top: 60px;
}

.sidenav a {
  padding: 8px 8px 8px 32px;
  text-decoration: none;
  font-size: 25px;
  color: #818181;
  display: block;
  transition: 0.3s;
}

.sidenav a:hover {
  color: #f1f1f1;
}

.sidenav .closebtn {
  position: absolute;
  top: 0;
  right: 25px;
  color: #ccc;
  font-size: 36px;
  margin-left: 50px;
}

@media screen and (max-height: 450px) {
  .sidenav {padding-top: 15px;}
  .sidenav a {font-size: 18px;}
}

.sidenavtext{
color: #F386FF;
}
</style>
</head>

<body>

<div id="mySidenav" class="sidenav">
<a href="javascript:void(0)" class="closebtn" onclick="closeNav()">&times;</a>
<br>
<span class="sidenavtext" >Webcam:</span><br>
<select id="whichcam">
<option value="0">back cam</option>
<option value="1">front cam</option>
</select>


</div>


<span style="font-size:25px;cursor:pointer" onclick="openNav()">&#9776; </span>



<select id="pickeffect">
<option value="1">RGB Original</option>
<option value="58">LBP feature</option>
<option value="59">LGP feature</option>
<option value="60">LTP feature</option>
<option value="61">RankTransform</option>
<option value="62">TS0 LocalPattern</option>
<option value="63">TS1 LocalPattern</option>
<option value="64">STS LocalPattern</option>
<option value="65">STU LocalPattern</option>
<option value="66">MTS LocalPattern</option>
<option value="67">ILBP LocalPattern</option>
<option value="68">MBP LocalPattern</option>
<option value="69">CSLBP LocalPattern</option>
<option value="70">CBP LocalPattern</option>
<option value="71">CCR LocalPattern</option>
<option value="72">ILTP LocalPattern</option>
<option value="73">CLBP C & M LocalPattern</option>
<option value="74">LQP LocalPattern</option>
<option value="75">BGC LocalPattern</option>
<option value="76">GLBP LocalPattern</option>
<option value="77">HOG Descriptor</option>
<option value="78">Harris CornerDetection</option>

</select>

<input type="button" id="StartCam" value="StartCam" onclick="StartCam()"> 
<input type="button" id="StopCam" value="StopCam" onclick="StopCam()"> 
<input type="button" id="CaptureImg" value="Capture" onclick="downloadCanvasImage()"> 
<input type="button" id="RefreshImg" value="Refresh" onclick="RefreshCanvasImage()"> 

<input type="file" id="file_input">
<input type="button" value="upload" id="file_button" onclick="getFileInput()">

<input type="checkbox" id="check_1" name="check_1" value="1" checked onclick="check_1()"><label for="check_1"> display original </label>
<input type="checkbox" id="check_2" name="check_2" value="1" checked="" onclick="check_2()"><label for="check_2"> sub inputs </label>


<br>
<div id='subinputs'></div>
<br>
<img id="myimage">
<video  class="player2 vsc initialized"></video>
<div class="container">
	<canvas class="photo"></canvas>
	<canvas id="obj" width="256" height="256"></canvas>
</div>

<script>

var MediaStream=null;
var ccnt=0;
let intervalID = null;
var width = 1;
var height = 1;
var CurrentInputType=0;//1-video,2-image
var InputFieldsAll=new Array(10);
var jsloadedflag = false;
var is_cv_loaded=false;

var framecount=0;
var effect_name='';

var camchoices=["environment","user"];
var currentcam=camchoices[0];

const fnnames={
'1':'rgbOriginal',
'58':'LBP_LocalPattern',
'59':'LGP_LocalPattern',
'60':'LTP_LocalPattern',
'61':'RT_LocalPattern',
'62':'TS0_LocalPattern',
'63':'TS1_LocalPattern',
'64':'STS_LocalPattern',
'65':'STU_LocalPattern',
'66':'MTS_LocalPattern',
'67':'ILBP_LocalPattern',
'68':'MBP_LocalPattern',
'69':'CSLBP_LocalPattern',
'70':'CBP_LocalPattern',
'71':'CCR_LocalPattern',
'72':'ILTP_LocalPattern',
'73':'CLBP_C_M_LocalPattern',
'74':'LQP_LocalPattern',
'75':'BGC_LocalPattern',
'76':'GLBP_LocalPattern',
'77':'HOG_Descriptor',
'78':'Harris_Descriptor',
'79':'GLBP_LocalPattern',
'80':'GLBP_LocalPattern',

};

const video = document.querySelector('.player2');
const canvas = document.querySelector('.photo');
const ctx = canvas.getContext('2d');
var input_1 = document.getElementById("file_input");
var myimage = document.getElementById("myimage");
var div_1 = document.getElementById("subinputs");


var element = document.getElementById("pickeffect");
var eleval1=element.value;
if ((Math.floor(eleval1)>76)&&(is_cv_loaded==false)) {
loadcv2_module();
}
currentEffect=window[fnnames[eleval1]];
var effect_name=currentEffect.name;

element.onchange=function(){
var eleval1=element.value;

if ((Math.floor(eleval1)>76)&&(is_cv_loaded==false)) {
loadcv2_module();
}

currentEffect=window[fnnames[eleval1]];
effect_name=currentEffect.name;
set_subinputs();

if (CurrentInputType==1){
paintToCanvas(currentEffect);
}
if (CurrentInputType==2) {
paint2();
}
}

var element2 = document.getElementById("whichcam");
element2.onchange=function(){
currentcam=camchoices[element2.value];
getCamVideo(currentcam);
video.addEventListener('canplay', function () { paintToCanvas(currentEffect) });
}

var element3 = document.getElementById("check_1");
var element4 = document.getElementById("check_2");
set_subinputs();


function openNav() {
  document.getElementById("mySidenav").style.width = "250px";
}

function closeNav() {
  document.getElementById("mySidenav").style.width = "0";
}

const AutoDownload = (dataUrl, filename) => {
  const link = document.createElement("a");
  link.href = dataUrl;
  link.download = filename;
  link.click();
};

function loadJs(url, cb) {
  var script = document.createElement('script');
  script.setAttribute('src', url);
  script.setAttribute('type', 'text/javascript');

  jsloadedflag = false;
  var loadFunction = function () {
    if (jsloadedflag) return;
    jsloadedflag = true;
    cb();
  };
  script.onload = loadFunction;
  script.onreadystatechange = loadFunction;
  document.getElementsByTagName("head")[0].appendChild(script);
};

function factorial(n) {
  loadJs('functions.js', function() {
    factorial(n);
  });
}

function loadcv2_module(){
var cvsrc='https://docs.opencv.org/3.4.0/opencv.js';
loadJs(cvsrc, function() {});
is_cv_loaded=jsloadedflag;
}

function downloadCanvasImage(){
var tmpimg    = canvas.toDataURL("image/png");
let today = new Date().toISOString().replaceAll(':','-').replaceAll('.','-');
filename="canvas_"+today+".png";
AutoDownload(tmpimg,filename);
}

function RefreshCanvasImage(){
if (CurrentInputType==1){
paintToCanvas(currentEffect);
}
if (CurrentInputType==2) {
paint2();
}
}

function set_subinputs(){
div_1.innerHTML = "";

if (effect_name=='LTP_LocalPattern'){
div_1.appendChild(document.createTextNode("T Value:"));
var inp1 = document.createElement("input");
inp1.value='3'
div_1.appendChild(inp1);
div_1.appendChild(document.createTextNode("Lower(0) or Upper(1):"));
var inp2 = document.createElement("input");
inp2.value='0'
div_1.appendChild(inp2);
InputFieldsAll=[inp1,inp2];
}

if (effect_name=='TS1_LocalPattern'){
div_1.appendChild(document.createTextNode("T Value:"));
var inp1 = document.createElement("input");
inp1.value='5'
div_1.appendChild(inp1);
InputFieldsAll=[inp1];
}

if (effect_name=='STU_LocalPattern'){
div_1.appendChild(document.createTextNode("T Value:"));
var inp1 = document.createElement("input");
inp1.value='3'
div_1.appendChild(inp1);
div_1.appendChild(document.createTextNode("horizontal&vertical(0) or Diagonal(1):"));
var inp2 = document.createElement("input");
inp2.value='0'
div_1.appendChild(inp2);
InputFieldsAll=[inp1,inp2];
}

if (effect_name=='CSLBP_LocalPattern'){
div_1.appendChild(document.createTextNode("T Value:"));
var inp1 = document.createElement("input");
inp1.value='3'
div_1.appendChild(inp1);
InputFieldsAll=[inp1];
}

if (effect_name=='CBP_LocalPattern'){
div_1.appendChild(document.createTextNode("T Value:"));
var inp1 = document.createElement("input");
inp1.value='3'
div_1.appendChild(inp1);
InputFieldsAll=[inp1];
}

if (effect_name=='ILTP_LocalPattern'){
div_1.appendChild(document.createTextNode("T Value:"));
var inp1 = document.createElement("input");
inp1.value='3'
div_1.appendChild(inp1);
div_1.appendChild(document.createTextNode("Lower(0) or Upper(1):"));
var inp2 = document.createElement("input");
inp2.value='0'
div_1.appendChild(inp2);
InputFieldsAll=[inp1,inp2];
}

if (effect_name=='CLBP_C_M_LocalPattern'){
div_1.appendChild(document.createTextNode("CLBP-C(0) CLBP-M(1):"));
var inp1 = document.createElement("input");
inp1.value='0'
div_1.appendChild(inp1);
InputFieldsAll=[inp1];
}

if (effect_name=='LQP_LocalPattern'){
div_1.appendChild(document.createTextNode("TValue 1:"));
var inp1 = document.createElement("input");
inp1.value='3'
div_1.appendChild(inp1);
div_1.appendChild(document.createTextNode("TValue 2:"));
var inp2 = document.createElement("input");
inp2.value='6'
div_1.appendChild(inp2);
div_1.appendChild(document.createTextNode("LQP-2(0), LQP-1(1), LQP+1(2), LQP+2(3):"));
var inp3 = document.createElement("input");
inp3.value='0'
div_1.appendChild(inp3);
InputFieldsAll=[inp1,inp2,inp3];
}

if (effect_name=='BGC_LocalPattern'){
div_1.appendChild(document.createTextNode("BGC1(0), BGC2_1(1), BGC2_2(2), BGC3(3):"));
var inp1 = document.createElement("input");
inp1.value='0'
div_1.appendChild(inp1);
InputFieldsAll=[inp1];
}

if (effect_name=='HOG_Descriptor'){
div_1.appendChild(document.createTextNode("GradientX(0), GradientY(1), Magnitude(2), Orientation(3), HOG(4):"));
var inp1 = document.createElement("input");
inp1.value='0'
div_1.appendChild(inp1);
div_1.appendChild(document.createTextNode("Cellsize:"));
var inp2 = document.createElement("input");
inp2.value='15'
div_1.appendChild(inp2);
div_1.appendChild(document.createTextNode("Binsize:"));
var inp3 = document.createElement("input");
inp3.value='6'
div_1.appendChild(inp3);
InputFieldsAll=[inp1,inp2,inp3];
}

check_2();
}

function reset_all(){
CurrentInputType=0;
video.src = "";
video.controls = false;
video.srcObject = null;
video.style.display="none";
clearInterval(intervalID);
if (MediaStream!=null) MediaStream.stop();
myimage.style.display="none";
myimage.src="";
ctx.clearRect(0, 0, canvas.width, canvas.height);
}

function getFileInput() {
const file=input_1.files[0];
const fileType = file['type'];
const validImageTypes = ['image/gif', 'image/jpeg', 'image/png'];
var URL = window.webkitURL || window.URL;
var url = URL.createObjectURL(file);
if (validImageTypes.includes(fileType)) {
reset_all();
CurrentInputType=2;
framecount=0;
//myimage.style.display="initial";
check_1();
myimage.src=url;
myimage.onload = function() {
paint2();
}
} else {
reset_all();
CurrentInputType=1;
framecount=0;
video.src = url;
video.controls = true;
video.style.display="initial";
video.addEventListener('canplay', function () { paintToCanvas(currentEffect) });
video.play();
}
}

function paint2(){
width = myimage.width;
height = myimage.height;
//alert(width+'x'+height)
canvas.width = width;
canvas.height = height;
effect_name=currentEffect.name;
ctx.drawImage(myimage, 0, 0, width, height);
let pixels = ctx.getImageData(0, 0, width, height);
pixels = currentEffect(pixels);
ctx.putImageData(pixels, 0, 0);
}

function getCamVideo(currentcam) {
navigator.mediaDevices.getUserMedia({ video: {facingMode: currentcam}, audio: false })
.then(localMediaStream => {
MediaStream=localMediaStream;
MediaStream.stop = function () {
this.getAudioTracks().forEach(function (track) {
	track.stop();
});
this.getVideoTracks().forEach(function (track) { //in case... :)
	track.stop();
});
};
video.src = "";
video.controls = false;
video.srcObject = localMediaStream;
video.play();
})
.catch(err => {
  console.error('OH OH!', err);
});
}

function paintToCanvas(effect) {
if (intervalID !== null) {
clearInterval(intervalID);
}
width=video.videoWidth;
height=video.videoHeight;
canvas.width = width;
canvas.height = height;
effect_name=effect.name;

function paintWithEffect() {
ctx.drawImage(video, 0, 0, width, height);
let pixels = ctx.getImageData(0, 0, width, height);
framecount+=1;
pixels = effect(pixels);
ctx.putImageData(pixels, 0, 0);
}
intervalID = setInterval(paintWithEffect, 30);
}

function StartCam(){
reset_all();
check_1();
check_2();
CurrentInputType=1;
framecount=0;
getCamVideo(currentcam);
video.addEventListener('canplay', function () { paintToCanvas(currentEffect) });
}

function StopCam(){
reset_all();
CurrentInputType=0;
}

function check_1(){
if (element3.checked) {
video.style.display="initial";
myimage.style.display="initial";
} else {
video.style.display="none";
myimage.style.display="none";
}
}

function check_2(){
if (element4.checked) {
div_1.style.display="initial";
} else {
div_1.style.display="none";
}
}

function rgbOriginal(pixels) {
//console.log('total:',pixels.data.length,'width:',video.videoWidth,'height:',video.videoHeight)
return pixels;
}

function rgb2gray(pixels) {
//console.log('total:',pixels.data.length,'width:',video.videoWidth,'height:',video.videoHeight)
for (let i = 0; i < pixels.data.length; i += 4) {
var gray=Math.floor(0.2989 * pixels.data[i + 0] + 0.5870 * pixels.data[i + 1] + 0.1140 * pixels.data[i + 2]);
pixels.data[i + 0] = gray;
pixels.data[i + 1] = gray;
pixels.data[i + 2] = gray;
pixels.data[i + 3] = 255;
}
return pixels;
}

findMax = a => a.reduce((res,cur) => res < cur ? cur : res ,-Infinity);
findMin = a => a.reduce((res,cur) => res > cur ? cur : res ,Infinity);

function LBP_LocalPattern(pixels) {
//local binary pattern
var data = pixels.data;
var grayImage = new Array(width * height);

for (let i = 0; i < data.length; i += 4) {
  const grayValue = Math.round(
	(data[i] + data[i + 1] + data[i + 2]) / 3
  );
  grayImage[i / 4] = grayValue;
}

const lbpImage = new Array(width * height);
for (let i = 1; i < height - 1; i++) {
  for (let j = 1; j < width - 1; j++) {
	const center = grayImage[i * width + j];
	let code = 0;
	code |= (grayImage[(i - 1) * width + (j - 1)] > center) << 7;
	code |= (grayImage[(i - 1) * width + j] > center) << 6;
	code |= (grayImage[(i - 1) * width + (j + 1)] > center) << 5;
	code |= (grayImage[i * width + (j + 1)] > center) << 4;
	code |= (grayImage[(i + 1) * width + (j + 1)] > center) << 3;
	code |= (grayImage[(i + 1) * width + j] > center) << 2;
	code |= (grayImage[(i + 1) * width + (j - 1)] > center) << 1;
	code |= (grayImage[i * width + (j - 1)] > center) << 0;
	lbpImage[i * width + j] = code;
  }
}

for (let i = 0; i < lbpImage.length; i++) {
  const code = lbpImage[i];
  const value = Math.round((code / 255) * 255);
  data[i * 4] = value;
  data[i * 4 + 1] = value;
  data[i * 4 + 2] = value;
  data[i * 4 + 3] = 255;
}
pixels.data=data;
return pixels;
}

function LGP_LocalPattern(pixels) {
//local gradient pattern
var data = pixels.data;
var grayImage = new Array(width * height);

for (let i = 0; i < data.length; i += 4) {
  const grayValue = Math.round(
	(data[i] + data[i + 1] + data[i + 2]) / 3
  );
  grayImage[i / 4] = grayValue;
}

var base2nums=[128,64,32,16,8,4,2,1];
var a1,a2,a3,a4,a5,a6,a7,a8,a9=0;
const lgpImage = new Array(width * height);
for (let i = 1; i < height - 1; i++) {
  for (let j = 1; j < width - 1; j++) {
	const center = grayImage[i * width + j];//a5
	a1=grayImage[(i - 1) * width + (j - 1)];
	a2=grayImage[(i - 1) * width + j];
	a3=grayImage[(i - 1) * width + (j + 1)];
	a4=grayImage[i * width + (j + 1)];
	a5=grayImage[(i + 1) * width + (j + 1)];
	a6=grayImage[(i + 1) * width + j];
	a7=grayImage[(i + 1) * width + (j - 1)];
	a8=grayImage[i * width + (j - 1)];
	// [a1,a2,a3,
	//	a8,center,a4,
	//	a7,a6,a5]
	var g_mean=Math.abs(a1+a2+a3+a4+a5+a6+a7+a8-8*center)/8;

	label=(Math.abs(a1-center)>g_mean)*base2nums[0]+(Math.abs(a2-center)>g_mean)*base2nums[1]+(Math.abs(a3-center)>g_mean)*base2nums[2]+(Math.abs(a4-center)>g_mean)*base2nums[3]+(Math.abs(a5-center)>g_mean)*base2nums[4]+(Math.abs(a6-center)>g_mean)*base2nums[5]+(Math.abs(a7-center)>g_mean)*base2nums[6]+(Math.abs(a8-center)>g_mean)*base2nums[7];
	lgpImage[i * width + j] = label;
  }
}

for (let i = 0; i < lgpImage.length; i++) {
  const value = lgpImage[i];
  data[i * 4] = value;
  data[i * 4 + 1] = value;
  data[i * 4 + 2] = value;
  data[i * 4 + 3] = 255;
}
pixels.data=data;
return pixels;
}

function LTP_LocalPattern(pixels) {
//local ternary pattern
var data = pixels.data;
var grayImage = new Array(width * height);

for (let i = 0; i < data.length; i += 4) {
  const grayValue = Math.round(
	(data[i] + data[i + 1] + data[i + 2]) / 3
  );
  grayImage[i / 4] = grayValue;
}

//var th=3;
var th=Math.floor(InputFieldsAll[0].value);
var choice=InputFieldsAll[1].value;
var code=0;

var base2nums=[128,64,32,16,8,4,2,1];
var a1,a2,a3,a4,a5,a6,a7,a8,a9=0;
const ltp_low = new Array(width * height);
const ltp_high = new Array(width * height);
for (let i = 1; i < height - 1; i++) {
  for (let j = 1; j < width - 1; j++) {
	var center = grayImage[i * width + j];//a5
	a1=grayImage[(i - 1) * width + (j - 1)];
	a2=grayImage[(i - 1) * width + j];
	a3=grayImage[(i - 1) * width + (j + 1)];
	a4=grayImage[i * width + (j + 1)];
	a5=grayImage[(i + 1) * width + (j + 1)];
	a6=grayImage[(i + 1) * width + j];
	a7=grayImage[(i + 1) * width + (j - 1)];
	a8=grayImage[i * width + (j - 1)];
	// [a1,a2,a3,
	//	a8,center,a4,
	//	a7,a6,a5]
	low=center-th;
	high=center+th;
	
	ltp_l=(a1<=low)*base2nums[0]+(a2<=low)*base2nums[1]+(a3<=low)*base2nums[2]+(a4<=low)*base2nums[3]+(a5<=low)*base2nums[4]+(a6<=low)*base2nums[5]+(a7<=low)*base2nums[6]+(a8<=low)*base2nums[7];
	ltp_h=(a1>high)*base2nums[0]+(a2>high)*base2nums[1]+(a3>high)*base2nums[2]+(a4>high)*base2nums[3]+(a5>high)*base2nums[4]+(a6>high)*base2nums[5]+(a7>high)*base2nums[6]+(a8>high)*base2nums[7];
	
	ltp_low[i * width + j] = ltp_l;
	ltp_high[i * width + j] = ltp_h;
  }
}

for (let i = 0; i < ltp_low.length; i++) {
if (choice==0){
  code = ltp_low[i];
  } else {
  code = ltp_high[i];
  }
  //code = ltp_low[i];
  //let value = Math.round((code / 255) * 255);
  var value =Math.round(code);
  data[i * 4] = value;
  data[i * 4 + 1] = value;
  data[i * 4 + 2] = value;
  data[i * 4 + 3] = 255;
}
pixels.data=data;
return pixels;
}
 
function RT_LocalPattern(pixels) {
//Rank Transform
var data = pixels.data;
var grayImage = new Array(width * height);

for (let i = 0; i < data.length; i += 4) {
  const grayValue = Math.round(
	(data[i] + data[i + 1] + data[i + 2]) / 3
  );
  grayImage[i / 4] = grayValue;
}

var base2nums=[128,64,32,16,8,4,2,1];
var uint8_labels=[0,32,64,96,128,160,192,224,256];
var a1,a2,a3,a4,a5,a6,a7,a8,a9=0;
const label_im = new Array(width * height);
for (let i = 1; i < height - 1; i++) {
  for (let j = 1; j < width - 1; j++) {
	var center = grayImage[i * width + j];//a5
	a1=grayImage[(i - 1) * width + (j - 1)];
	a2=grayImage[(i - 1) * width + j];
	a3=grayImage[(i - 1) * width + (j + 1)];
	a4=grayImage[i * width + (j + 1)];
	a5=grayImage[(i + 1) * width + (j + 1)];
	a6=grayImage[(i + 1) * width + j];
	a7=grayImage[(i + 1) * width + (j - 1)];
	a8=grayImage[i * width + (j - 1)];
	// [a1,a2,a3,
	//	a8,center,a4,
	//	a7,a6,a5]
	label=(a1<center)+(a2<center)+(a3<center)+(a4<center)+(a5<center)+(a6<center)+(a7<center)+(a8<center);
	label_im[i * width + j]=label;
  }
}

for (let i = 0; i < label_im.length; i++) {
  const value =uint8_labels[Math.floor(label_im[i])];
  data[i * 4] = value;
  data[i * 4 + 1] = value;
  data[i * 4 + 2] = value;
  data[i * 4 + 3] = 255;
}
pixels.data=data;
return pixels;
}

function TS0_condition(a1,center){
if (a1<center) return 0;
if (a1==center) return 1;
if (a1>center) return 2;
}

function TS1_condition(a1,center,T_value){
if (a1<(center-T_value)) return 0;
if ((a1>=(center-T_value))&&(a1<=(center+T_value))) return 1;
if (a1>(center+T_value)) return 2;
}

function STS_condition(a1,center,T_value){
if (a1<(center-T_value)) return 0;
if ((a1>=(center-T_value))&&(a1<=(center+T_value))) return 1;
if (a1>(center+T_value)) return 2;
}

function STU_condition(a1,center,T_value){
if (a1<(center-T_value)) return 0;
if ((a1>=(center-T_value))&&(a1<=(center+T_value))) return 1;
if (a1>(center+T_value)) return 2;
}

function TS0_LocalPattern(pixels) {
//Texture Spectrum
var data = pixels.data;
var grayImage = new Array(width * height);
for (let i = 0; i < data.length; i += 4) {
  const grayValue = Math.round(
	(data[i] + data[i + 1] + data[i + 2]) / 3
  );
  grayImage[i / 4] = grayValue;
}

var base3nums=[2187,729,243,81,27,9,3,1];

var a1,a2,a3,a4,a5,a6,a7,a8,a9=0;
const label_im = new Array(width * height);
for (let i = 1; i < height - 1; i++) {
  for (let j = 1; j < width - 1; j++) {
	var center = grayImage[i * width + j];//a5
	a1=grayImage[(i - 1) * width + (j - 1)];
	a2=grayImage[(i - 1) * width + j];
	a3=grayImage[(i - 1) * width + (j + 1)];
	a4=grayImage[i * width + (j + 1)];
	a5=grayImage[(i + 1) * width + (j + 1)];
	a6=grayImage[(i + 1) * width + j];
	a7=grayImage[(i + 1) * width + (j - 1)];
	a8=grayImage[i * width + (j - 1)];
	label=TS0_condition(a1,center)*base3nums[0]+TS0_condition(a2,center)*base3nums[1]+TS0_condition(a3,center)*base3nums[2]+TS0_condition(a4,center)*base3nums[3]+TS0_condition(a5,center)*base3nums[4]+TS0_condition(a6,center)*base3nums[5]+TS0_condition(a7,center)*base3nums[6]+TS0_condition(a8,center)*base3nums[7];
	label_im[i * width + j]=label;
  }
}

for (let i = 0; i < label_im.length; i++) {
  const value =Math.floor((label_im[i]/6560)*16777216);//normalize to rgb range 0-256**3
  let r=Math.floor(value/(256**2));
  let g=Math.floor((value%(256**2))/256);
  let b=Math.floor(value%256);
  
  data[i * 4] = r;
  data[i * 4 + 1] = g;
  data[i * 4 + 2] = b;
  data[i * 4 + 3] = 255;
}
pixels.data=data;
return pixels;
}

function TS1_LocalPattern(pixels) {
//Texture Spectrum
var data = pixels.data;
var grayImage = new Array(width * height);
for (let i = 0; i < data.length; i += 4) {
  const grayValue = Math.round(
	(data[i] + data[i + 1] + data[i + 2]) / 3
  );
  grayImage[i / 4] = grayValue;
}

//var T_value=5;
var T_value=Math.floor(InputFieldsAll[0].value);
var base3nums=[2187,729,243,81,27,9,3,1];

var a1,a2,a3,a4,a5,a6,a7,a8,a9=0;
var label_im = new Array(width * height);
for (let i = 1; i < height - 1; i++) {
  for (let j = 1; j < width - 1; j++) {
	var center = grayImage[i * width + j];//a5
	a1=grayImage[(i - 1) * width + (j - 1)];
	a2=grayImage[(i - 1) * width + j];
	a3=grayImage[(i - 1) * width + (j + 1)];
	a4=grayImage[i * width + (j + 1)];
	a5=grayImage[(i + 1) * width + (j + 1)];
	a6=grayImage[(i + 1) * width + j];
	a7=grayImage[(i + 1) * width + (j - 1)];
	a8=grayImage[i * width + (j - 1)];
	label=TS1_condition(a1,center,T_value)*base3nums[0]+TS1_condition(a2,center,T_value)*base3nums[1]+TS1_condition(a3,center,T_value)*base3nums[2]+TS1_condition(a4,center,T_value)*base3nums[3]+TS1_condition(a5,center,T_value)*base3nums[4]+TS1_condition(a6,center,T_value)*base3nums[5]+TS1_condition(a7,center,T_value)*base3nums[6]+TS1_condition(a8,center,T_value)*base3nums[7];
	label_im[i * width + j]=label;
  }
}

for (let i = 0; i < label_im.length; i++) {
  let value =Math.floor((label_im[i]/6560)*16777216);//normalize to rgb range 0-256**3
  let r=Math.floor(value/(256**2));
  let g=Math.floor((value%(256**2))/256);
  let b=Math.floor(value%256);
  
  data[i * 4] = r;
  data[i * 4 + 1] = g;
  data[i * 4 + 2] = b;
  data[i * 4 + 3] = 255;
}
pixels.data=data;
return pixels;
}

function STS_LocalPattern(pixels) {
//Simplified Texture Spectrum
var data = pixels.data;
var grayImage = new Array(width * height);
for (let i = 0; i < data.length; i += 4) {
  const grayValue = Math.round(
	(data[i] + data[i + 1] + data[i + 2]) / 3
  );
  grayImage[i / 4] = grayValue;
}

var T_value=0;
var base3nums=[2187,729,243,81,27,9,3,1];

var a1,a2,a3,a4,a5,a6,a7,a8,a9=0;
var label_im = new Array(width * height);
for (let i = 1; i < height - 1; i++) {
  for (let j = 1; j < width - 1; j++) {
	var center = grayImage[i * width + j];//a5
	//a1=grayImage[(i - 1) * width + (j - 1)];
	//a2=grayImage[(i - 1) * width + j];
	//a3=grayImage[(i - 1) * width + (j + 1)];
	a4=grayImage[i * width + (j + 1)];
	a5=grayImage[(i + 1) * width + (j + 1)];
	a6=grayImage[(i + 1) * width + j];
	a7=grayImage[(i + 1) * width + (j - 1)];
	//a8=grayImage[i * width + (j - 1)];
	label=STS_condition(a4,center,T_value)*base3nums[4]+STS_condition(a5,center,T_value)*base3nums[5]+STS_condition(a6,center,T_value)*base3nums[6]+STS_condition(a7,center,T_value)*base3nums[7];
	label_im[i * width + j]=label;
  }
}
for (let i = 0; i < label_im.length; i++) {
  let value =Math.floor((label_im[i]/81)*255);//normalize to range 0-255
  let r=value;
  let g=value;
  let b=value;
  
  data[i * 4] = r;
  data[i * 4 + 1] = g;
  data[i * 4 + 2] = b;
  data[i * 4 + 3] = 255;
}
pixels.data=data;
return pixels;
}

function STU_LocalPattern(pixels) {
//Simplified Texture Unit
var data = pixels.data;
var grayImage = new Array(width * height);
for (let i = 0; i < data.length; i += 4) {
  const grayValue = Math.round(
	(data[i] + data[i + 1] + data[i + 2]) / 3
  );
  grayImage[i / 4] = grayValue;
}

var T_value=Math.floor(InputFieldsAll[0].value);//3
var choice=Math.floor(InputFieldsAll[1].value);//0-horizontal & vertical; 1-diagonals
var base3nums=[2187,729,243,81,27,9,3,1];

var a1,a2,a3,a4,a5,a6,a7,a8,a9=0;
var label_im = new Array(width * height);
for (let i = 1; i < height - 1; i++) {
  for (let j = 1; j < width - 1; j++) {
	var center = grayImage[i * width + j];//a5

	// [a1,a2,a3,
	//	a8,center,a4,
	//	a7,a6,a5]
	if (choice==0){
		a2=grayImage[(i - 1) * width + j];
		a4=grayImage[i * width + (j + 1)];
		a6=grayImage[(i + 1) * width + j];
		a8=grayImage[i * width + (j - 1)];
		label=STU_condition(a2,center,T_value)*base3nums[4]+STU_condition(a4,center,T_value)*base3nums[5]+STU_condition(a6,center,T_value)*base3nums[6]+STU_condition(a8,center,T_value)*base3nums[7];
	}
	if (choice==1){
		a1=grayImage[(i - 1) * width + (j - 1)];
		a3=grayImage[(i - 1) * width + (j + 1)];
		a5=grayImage[(i + 1) * width + (j + 1)];
		a7=grayImage[(i + 1) * width + (j - 1)];
		label=STU_condition(a1,center,T_value)*base3nums[4]+STU_condition(a3,center,T_value)*base3nums[5]+STU_condition(a5,center,T_value)*base3nums[6]+STU_condition(a7,center,T_value)*base3nums[7];
	}
	label_im[i * width + j]=label;
  }
}
//16777216
for (let i = 0; i < label_im.length; i++) {
  let value =Math.floor((label_im[i]/81)*255);//normalize to 0-255
  let r=value;
  let g=value;
  let b=value;
  
  data[i * 4] = r;
  data[i * 4 + 1] = g;
  data[i * 4 + 2] = b;
  data[i * 4 + 3] = 255;
}
pixels.data=data;
return pixels;
}

function MTS_LocalPattern(pixels) {
//Modified Texture Spectrum
var data = pixels.data;
var grayImage = new Array(width * height);
for (let i = 0; i < data.length; i += 4) {
  const grayValue = Math.round(
	(data[i] + data[i + 1] + data[i + 2]) / 3
  );
  grayImage[i / 4] = grayValue;
}

var base2nums=[128,64,32,16,8,4,2,1];

var a1,a2,a3,a4,a5,a6,a7,a8,a9=0;
var label_im = new Array(width * height);
for (let i = 1; i < height - 1; i++) {
  for (let j = 1; j < width - 1; j++) {
	var center = grayImage[i * width + j];//a5
	//a1=grayImage[(i - 1) * width + (j - 1)];
	//a2=grayImage[(i - 1) * width + j];
	//a3=grayImage[(i - 1) * width + (j + 1)];
	a4=grayImage[i * width + (j + 1)];
	a5=grayImage[(i + 1) * width + (j + 1)];
	a6=grayImage[(i + 1) * width + j];
	a7=grayImage[(i + 1) * width + (j - 1)];
	//a8=grayImage[i * width + (j - 1)];
	label=(a4>center)*base2nums[4]+(a5>center)*base2nums[5]+(a6>center)*base2nums[6]+(a7>center)*base2nums[7];
	label_im[i * width + j]=label;
  }
}
for (let i = 0; i < label_im.length; i++) {
  let value =Math.floor((label_im[i]/16)*255);//normalize to range 0-255
  let r=value;
  let g=value;
  let b=value;
  
  data[i * 4] = r;
  data[i * 4 + 1] = g;
  data[i * 4 + 2] = b;
  data[i * 4 + 3] = 255;
}
pixels.data=data;
return pixels;
}

function ILBP_LocalPattern(pixels) {
//Improved Local Binary Pattern
var data = pixels.data;
var grayImage = new Array(width * height);
for (let i = 0; i < data.length; i += 4) {
  const grayValue = Math.round((data[i] + data[i + 1] + data[i + 2]) / 3);
  grayImage[i / 4] = grayValue;
}

var base2nums=[128,64,32,16,8,4,2,1];

var a1,a2,a3,a4,a5,a6,a7,a8,a9=0;
var label_im = new Array(width * height);
for (let i = 1; i < height - 1; i++) {
  for (let j = 1; j < width - 1; j++) {
	var center = grayImage[i * width + j];
	a1=grayImage[(i - 1) * width + (j - 1)];
	a2=grayImage[(i - 1) * width + j];
	a3=grayImage[(i - 1) * width + (j + 1)];
	a4=grayImage[i * width + (j + 1)];
	a5=grayImage[(i + 1) * width + (j + 1)];
	a6=grayImage[(i + 1) * width + j];
	a7=grayImage[(i + 1) * width + (j - 1)];
	a8=grayImage[i * width + (j - 1)];
	var mean=(a1+a2+a3+a4+a5+a6+a7+a8+center)/9;
	label=(center>mean)*(256)+(a1>mean)*base2nums[0]+(a2>mean)*base2nums[1]+(a3>mean)*base2nums[2]+(a4>mean)*base2nums[3]+(a5>mean)*base2nums[4]+(a6>mean)*base2nums[5]+(a7>mean)*base2nums[6]+(a8>mean)*base2nums[7]-1;
	label_im[i * width + j]=label;
  }
}

for (let i = 0; i < label_im.length; i++) {
  let value =Math.floor((label_im[i]/512)*16777216);
  let r=Math.floor(value/(256**2));
  let g=Math.floor((value%(256**2))/256);
  let b=Math.floor(value%256);
  
  data[i * 4] = r;
  data[i * 4 + 1] = g;
  data[i * 4 + 2] = b;
  data[i * 4 + 3] = 255;
}
pixels.data=data;
return pixels;
}

function MBP_LocalPattern(pixels) {
//Median Binary Pattern
var data = pixels.data;
var grayImage = new Array(width * height);
for (let i = 0; i < data.length; i += 4) {
  const grayValue = Math.round(
	(data[i] + data[i + 1] + data[i + 2]) / 3
  );
  grayImage[i / 4] = grayValue;
}

var T_value=0;
var base2nums=[128,64,32,16,8,4,2,1];

var a1,a2,a3,a4,a5,a6,a7,a8,a9=0;
var label_im = new Array(width * height);
for (let i = 1; i < height - 1; i++) {
  for (let j = 1; j < width - 1; j++) {
	var center = grayImage[i * width + j];
	a1=grayImage[(i - 1) * width + (j - 1)];
	a2=grayImage[(i - 1) * width + j];
	a3=grayImage[(i - 1) * width + (j + 1)];
	a4=grayImage[i * width + (j + 1)];
	a5=grayImage[(i + 1) * width + (j + 1)];
	a6=grayImage[(i + 1) * width + j];
	a7=grayImage[(i + 1) * width + (j - 1)];
	a8=grayImage[i * width + (j - 1)];
	var values=[a1,a2,a3,a4,a5,a6,a7,a8,center];
	values.sort(function(a, b){return a-b});
	var median=values[4];
	label=(center>median)*(256)+(a1>median)*base2nums[0]+(a2>median)*base2nums[1]+(a3>median)*base2nums[2]+(a4>median)*base2nums[3]+(a5>median)*base2nums[4]+(a6>median)*base2nums[5]+(a7>median)*base2nums[6]+(a8>median)*base2nums[7]-1;
	label_im[i * width + j]=label;
  }
}

for (let i = 0; i < label_im.length; i++) {
  let value =Math.floor((label_im[i]/512)*16777216);//normalize to rgb range 0-256**3
  let r=Math.floor(value/(256**2));
  let g=Math.floor((value%(256**2))/256);
  let b=Math.floor(value%256);
  
  data[i * 4] = r;
  data[i * 4 + 1] = g;
  data[i * 4 + 2] = b;
  data[i * 4 + 3] = 255;
}
pixels.data=data;
return pixels;
}

function CSLBP_LocalPattern(pixels) {
//Center Symmetric Local Binary Pattern
var data = pixels.data;
var grayImage = new Array(width * height);
for (let i = 0; i < data.length; i += 4) {
  const grayValue = Math.round(
	(data[i] + data[i + 1] + data[i + 2]) / 3
  );
  grayImage[i / 4] = grayValue;
}

var T_value=Math.floor(InputFieldsAll[0].value);//3
var base2nums=[128,64,32,16,8,4,2,1];

var a1,a2,a3,a4,a5,a6,a7,a8,a9=0;
var label_im = new Array(width * height);
for (let i = 1; i < height - 1; i++) {
  for (let j = 1; j < width - 1; j++) {
	var center = grayImage[i * width + j];
	a1=grayImage[(i - 1) * width + (j - 1)];
	a2=grayImage[(i - 1) * width + j];
	a3=grayImage[(i - 1) * width + (j + 1)];
	a4=grayImage[i * width + (j + 1)];
	a5=grayImage[(i + 1) * width + (j + 1)];
	a6=grayImage[(i + 1) * width + j];
	a7=grayImage[(i + 1) * width + (j - 1)];
	a8=grayImage[i * width + (j - 1)];
	label=(a1>a5-T_value)*base2nums[4]+(a2>a6-T_value)*base2nums[5]+(a3>a7-T_value)*base2nums[6]+(a4>a8-T_value)*base2nums[7];
	label_im[i * width + j]=label;
  }
}
for (let i = 0; i < label_im.length; i++) {
  let value =Math.floor((label_im[i]/16)*255);//normalizing to 0-255
  let r=value;
  let g=value;
  let b=value;
  
  data[i * 4] = r;
  data[i * 4 + 1] = g;
  data[i * 4 + 2] = b;
  data[i * 4 + 3] = 255;
}
pixels.data=data;
return pixels;
}

function CBP_LocalPattern(pixels) {
//Centralized Binary Pattern
var data = pixels.data;
var grayImage = new Array(width * height);
for (let i = 0; i < data.length; i += 4) {
  const grayValue = Math.round(
	(data[i] + data[i + 1] + data[i + 2]) / 3
  );
  grayImage[i / 4] = grayValue;
}

var T_value=Math.floor(InputFieldsAll[0].value);//3
var base2nums=[128,64,32,16,8,4,2,1];

var a1,a2,a3,a4,a5,a6,a7,a8,a9=0;
var label_im = new Array(width * height);
for (let i = 1; i < height - 1; i++) {
  for (let j = 1; j < width - 1; j++) {
	var center = grayImage[i * width + j];
	a1=grayImage[(i - 1) * width + (j - 1)];
	a2=grayImage[(i - 1) * width + j];
	a3=grayImage[(i - 1) * width + (j + 1)];
	a4=grayImage[i * width + (j + 1)];
	a5=grayImage[(i + 1) * width + (j + 1)];
	a6=grayImage[(i + 1) * width + j];
	a7=grayImage[(i + 1) * width + (j - 1)];
	a8=grayImage[i * width + (j - 1)];
	var mean=(a1+a2+a3+a4+a5+a6+a7+a8+center)/9;
	label=(Math.abs(center-mean)>T_value)*base2nums[5]+(Math.abs(a1-a5)>T_value)*base2nums[4]+(Math.abs(a2-a6)>T_value)*base2nums[5]+(Math.abs(a3-a7)>T_value)*base2nums[6]+(Math.abs(a4-a8)>T_value)*base2nums[7];
	label_im[i * width + j]=label;
  }
}

for (let i = 0; i < label_im.length; i++) {
  let value =Math.floor((label_im[i]/32)*255);//normalizing to 0-255
  let r=value;
  let g=value;
  let b=value;
  
  data[i * 4] = r;
  data[i * 4 + 1] = g;
  data[i * 4 + 2] = b;
  data[i * 4 + 3] = 255;
}
pixels.data=data;
return pixels;
}

function calculate_entropy(HistArray){
//val=0;
var val2=[];
NumPixels=width*height;
for (let i=0; i<HistArray.length; i++){
prob=HistArray[i]/NumPixels;
if (prob==0) prob=1;

//val+=(prob*Math.log2(prob));
val2.push(prob*Math.log2(prob));
}
//return (-val);
return val2;
}

function CCR_LocalPattern(pixels) {
//Coordinated Clusters Representation
var data = pixels.data;
var grayImage = new Array(width * height);
var histogram = new Array(256);
for (let i=0; i<256; i++) histogram[i] = 0;
for (let i = 0; i < data.length; i += 4) {
  const grayValue = Math.round((data[i] + data[i + 1] + data[i + 2]) / 3);
  grayImage[i / 4] = grayValue;
  histogram[grayValue]++;
}

diff_array=new Array(256);
prob_array=calculate_entropy(histogram);
for (let i = 0; i < 256; i++){
ent1=prob_array.slice(0,i).reduce((a, b) => a + b, 0);
ent2=prob_array.slice(i,).reduce((a, b) => a + b, 0);
diff1=Math.abs(ent1-ent2);
diff_array[i]=diff1;
}

var T_value=diff_array.indexOf(Math.min(...diff_array));
var base2nums=[128,64,32,16,8,4,2,1];

var a1,a2,a3,a4,a5,a6,a7,a8,a9=0;
var label_im = new Array(width * height);
for (let i = 1; i < height - 1; i++) {
  for (let j = 1; j < width - 1; j++) {
	var center = grayImage[i * width + j];
	a1=grayImage[(i - 1) * width + (j - 1)];
	a2=grayImage[(i - 1) * width + j];
	a3=grayImage[(i - 1) * width + (j + 1)];
	a4=grayImage[i * width + (j + 1)];
	a5=grayImage[(i + 1) * width + (j + 1)];
	a6=grayImage[(i + 1) * width + j];
	a7=grayImage[(i + 1) * width + (j - 1)];
	a8=grayImage[i * width + (j - 1)];

	label=(center>T_value)*(256)+(a1>T_value)*base2nums[0]+(a2>T_value)*base2nums[1]+(a3>T_value)*base2nums[2]+(a4>T_value)*base2nums[3]+(a5>T_value)*base2nums[4]+(a6>T_value)*base2nums[5]+(a7>T_value)*base2nums[6]+(a8>T_value)*base2nums[7]-1;
	label_im[i * width + j]=label;
  }
}

for (let i = 0; i < label_im.length; i++) {
  let value =Math.floor((label_im[i]/512)*16777216);//normalize to rgb range 0-256**3
  let r=Math.floor(value/(256**2));
  let g=Math.floor((value%(256**2))/256);
  let b=Math.floor(value%256);
  
  data[i * 4] = r;
  data[i * 4 + 1] = g;
  data[i * 4 + 2] = b;
  data[i * 4 + 3] = 255;
}
pixels.data=data;
return pixels;
}

function ILTP_LocalPattern(pixels) {
//Improved local ternary pattern
var data = pixels.data;
var grayImage = new Array(width * height);

for (let i = 0; i < data.length; i += 4) {
  var grayValue = Math.round((data[i] + data[i + 1] + data[i + 2]) / 3);
  grayImage[i / 4] = grayValue;
}

//var th=3;
var th=Math.floor(InputFieldsAll[0].value);
var choice=Math.floor(InputFieldsAll[1].value);
var code=0;

var base2nums=[128,64,32,16,8,4,2,1];
var a1,a2,a3,a4,a5,a6,a7,a8,a9=0;
var ltp_low = new Array(width * height);
var ltp_high = new Array(width * height);
for (let i = 1; i < height - 1; i++) {
  for (let j = 1; j < width - 1; j++) {
	center = grayImage[i * width + j];
	a1=grayImage[(i - 1) * width + (j - 1)];
	a2=grayImage[(i - 1) * width + j];
	a3=grayImage[(i - 1) * width + (j + 1)];
	a4=grayImage[i * width + (j + 1)];
	a5=grayImage[(i + 1) * width + (j + 1)];
	a6=grayImage[(i + 1) * width + j];
	a7=grayImage[(i + 1) * width + (j - 1)];
	a8=grayImage[i * width + (j - 1)];
	mean=Math.round((a1+a2+a3+a4+a5+a6+a7+a8+center)/9.0);
	low=mean-th;
	high=mean+th;
	
	ltp_l=(center<=low)*255+(a1<=low)*base2nums[0]+(a2<=low)*base2nums[1]+(a3<=high)*base2nums[2]+(a4<=low)*base2nums[3]+(a5<=low)*base2nums[4]+(a6<=low)*base2nums[5]+(a7<=low)*base2nums[6]+(a8<=low)*base2nums[7];
	ltp_h=(a1>high)*base2nums[0]+(a2>high)*base2nums[1]+(a3>high)*base2nums[2]+(a4>high)*base2nums[3]+(a5>high)*base2nums[4]+(a6>high)*base2nums[5]+(a7>high)*base2nums[6]+(a8>high)*base2nums[7];
	
	ltp_low[i * width + j] = ltp_l;
	ltp_high[i * width + j] = ltp_h;
  }
}

for (let i = 0; i < ltp_low.length; i++) {
if (choice==0){
  code = ltp_low[i];
  } else {
  code = ltp_high[i];
  }
  var value = Math.round((code / 512.0) * 255.0);
  //var value =Math.round(code);
  data[i * 4] = value;
  data[i * 4 + 1] = value;
  data[i * 4 + 2] = value;
  data[i * 4 + 3] = 255;
}
pixels.data=data;
return pixels;
}

function CLBP_C_M_LocalPattern(pixels) {
//Completed Local Binary Pattern
var data = pixels.data;
var graysum=0
var grayImage = new Array(width * height);
for (let i = 0; i < data.length; i += 4) {
  const grayValue = Math.round((data[i] + data[i + 1] + data[i + 2]) / 3);
  grayImage[i / 4] = grayValue;
  graysum+=grayValue;
}
avgpixel=Math.round(graysum/(width * height));

var choice=Math.floor(InputFieldsAll[0].value);
var base2nums=[128,64,32,16,8,4,2,1];

var a1,a2,a3,a4,a5,a6,a7,a8,a9=0;
var labelim_1 = new Array(width * height);
var labelim_2 = new Array(width * height);
for (let i = 1; i < height - 1; i++) {
  for (let j = 1; j < width - 1; j++) {
	var center = grayImage[i * width + j];
	a1=grayImage[(i - 1) * width + (j - 1)];
	a2=grayImage[(i - 1) * width + j];
	a3=grayImage[(i - 1) * width + (j + 1)];
	a4=grayImage[i * width + (j + 1)];
	a5=grayImage[(i + 1) * width + (j + 1)];
	a6=grayImage[(i + 1) * width + j];
	a7=grayImage[(i + 1) * width + (j - 1)];
	a8=grayImage[i * width + (j - 1)];
		
	label_1=Math.round(center>avgpixel);
	labelim_1[i * width + j]=label_1;
	
	var T_delta=(a1+a2+a3+a4+a5+a6+a7+a8-8*center)/8;
	label_2=(Math.abs(a1-center)>T_delta)*base2nums[0]+(Math.abs(a2-center)>T_delta)*base2nums[1]+(Math.abs(a3-center)>T_delta)*base2nums[2]+(Math.abs(a4-center)>T_delta)*base2nums[3]+(Math.abs(a5-center)>T_delta)*base2nums[4]+(Math.abs(a6-center)>T_delta)*base2nums[5]+(Math.abs(a7-center)>T_delta)*base2nums[6]+(Math.abs(a8-center)>T_delta)*base2nums[7];
	labelim_2[i * width + j]=label_2;
  }
}

var value=0;
for (let i = 0; i < labelim_1.length; i++) {
if (choice==0){
  value =Math.floor(labelim_1[i]*255);
  } else {
  value =Math.floor(labelim_2[i]);
  }
  let r=value;
  let g=value;
  let b=value;
  
  data[i * 4] = r;
  data[i * 4 + 1] = g;
  data[i * 4 + 2] = b;
  data[i * 4 + 3] = 255;
}
pixels.data=data;
return pixels;
}

function LQP_LocalPattern(pixels) {
//local quinary pattern
var data = pixels.data;
var grayImage = new Array(width * height);

for (let i = 0; i < data.length; i += 4) {
  const grayValue = Math.round(
	(data[i] + data[i + 1] + data[i + 2]) / 3
  );
  grayImage[i / 4] = grayValue;
}

var Tvalue_1=Math.floor(InputFieldsAll[0].value);//5
var Tvalue_2=Math.floor(InputFieldsAll[1].value);//10
var choice=InputFieldsAll[2].value;

var base2nums=[128,64,32,16,8,4,2,1];
var a1,a2,a3,a4,a5,a6,a7,a8,a9=0;
const im_minus2 = new Array(width * height);
const im_minus1 = new Array(width * height);
const im_plus1 = new Array(width * height);
const im_plus2 = new Array(width * height);
for (let i = 1; i < height - 1; i++) {
  for (let j = 1; j < width - 1; j++) {
	var center = grayImage[i * width + j];//a5
	a1=grayImage[(i - 1) * width + (j - 1)];
	a2=grayImage[(i - 1) * width + j];
	a3=grayImage[(i - 1) * width + (j + 1)];
	a4=grayImage[i * width + (j + 1)];
	a5=grayImage[(i + 1) * width + (j + 1)];
	a6=grayImage[(i + 1) * width + j];
	a7=grayImage[(i + 1) * width + (j - 1)];
	a8=grayImage[i * width + (j - 1)];

	L_1=center-Tvalue_1;
	H_1=center+Tvalue_1;
	L_2=center-Tvalue_2;
	H_2=center+Tvalue_2;
	
	v1=(a1<=L_1)*base2nums[0]+(a2<=L_1)*base2nums[1]+(a3<=L_1)*base2nums[2]+(a4<=L_1)*base2nums[3]+(a5<=L_1)*base2nums[4]+(a6<=L_1)*base2nums[5]+(a7<=L_1)*base2nums[6]+(a8<=L_1)*base2nums[7];
	v2=(a1<=L_2)*base2nums[0]+(a2<=L_2)*base2nums[1]+(a3<=L_2)*base2nums[2]+(a4<=L_2)*base2nums[3]+(a5<=L_2)*base2nums[4]+(a6<=L_2)*base2nums[5]+(a7<=L_2)*base2nums[6]+(a8<=L_2)*base2nums[7];
	v3=(a1>H_1)*base2nums[0]+(a2>H_1)*base2nums[1]+(a3>H_1)*base2nums[2]+(a4>H_1)*base2nums[3]+(a5>H_1)*base2nums[4]+(a6>H_1)*base2nums[5]+(a7>H_1)*base2nums[6]+(a8>H_1)*base2nums[7];
	v4=(a1>H_2)*base2nums[0]+(a2>H_2)*base2nums[1]+(a3>H_2)*base2nums[2]+(a4>H_2)*base2nums[3]+(a5>H_2)*base2nums[4]+(a6>H_2)*base2nums[5]+(a7>H_2)*base2nums[6]+(a8>H_2)*base2nums[7];
	
	im_minus2[i * width + j] = v2;
	im_minus1[i * width + j] = v1;
	im_plus1[i * width + j] = v3;
	im_plus2[i * width + j] = v4;
  }
}

var code=0;
for (let i = 0; i < im_minus2.length; i++) {
if (choice==0){
  code = im_minus2[i];
  } else if (choice==1){
  code = im_minus1[i];
  } else if (choice==2){
  code = im_plus1[i];
  } else {
  code = im_plus2[i];
  }
  var value =Math.round(code);
  data[i * 4] = value;
  data[i * 4 + 1] = value;
  data[i * 4 + 2] = value;
  data[i * 4 + 3] = 255;
}
pixels.data=data;
return pixels;
}

function BGC_LocalPattern(pixels) {
//Binary Gradient Contours
var data = pixels.data;
var grayImage = new Array(width * height);
for (let i = 0; i < data.length; i += 4) {
  const grayValue = Math.round((data[i] + data[i + 1] + data[i + 2]) / 3);
  grayImage[i / 4] = grayValue;
}

var choice=InputFieldsAll[0].value;
var base2nums=[128,64,32,16,8,4,2,1];

var a1,a2,a3,a4,a5,a6,a7,a8,a9=0;
var labelim_1 = new Array(width * height);
var labelim_2_1 = new Array(width * height);
var labelim_2_2 = new Array(width * height);
var labelim_3 = new Array(width * height);
for (let i = 1; i < height - 1; i++) {
  for (let j = 1; j < width - 1; j++) {
	var center = grayImage[i * width + j];
	a1=grayImage[(i - 1) * width + (j - 1)];
	a2=grayImage[(i - 1) * width + j];
	a3=grayImage[(i - 1) * width + (j + 1)];
	a4=grayImage[i * width + (j + 1)];
	a5=grayImage[(i + 1) * width + (j + 1)];
	a6=grayImage[(i + 1) * width + j];
	a7=grayImage[(i + 1) * width + (j - 1)];
	a8=grayImage[i * width + (j - 1)];

	label_1=(a1>a2)*base2nums[0]+(a2>a3)*base2nums[1]+(a3>a4)*base2nums[2]+(a4>a5)*base2nums[3]+(a5>a6)*base2nums[4]+(a6>a7)*base2nums[5]+(a7>a8)*base2nums[6]+(a8>a1)*base2nums[7];
	labelim_1[i * width + j]=label_1;
	
	//{1, 7, 5, 3, 1}
	label_2_1=(a2>a8)*base2nums[4]+(a8>a6)*base2nums[5]+(a6>a4)*base2nums[6]+(a4>a2)*base2nums[7];
	labelim_2_1[i * width + j]=label_2_1;
	
	//{0, 6, 4, 2, 0}
	label_2_2=(a1>a7)*base2nums[4]+(a7>a5)*base2nums[5]+(a5>a3)*base2nums[6]+(a3>a1)*base2nums[7];
	labelim_2_2[i * width + j]=label_2_2;
	
	//{0, 5, 2, 7, 4, 1, 6, 3, 0}
	label_3=(a1>a6)*base2nums[0]+(a6>a3)*base2nums[1]+(a3>a8)*base2nums[2]+(a8>a5)*base2nums[3]+(a5>a2)*base2nums[4]+(a2>a7)*base2nums[5]+(a7>a4)*base2nums[6]+(a4>a1)*base2nums[7];
	labelim_3[i * width + j]=label_3;
  }
}

var value=0;
for (let i = 0; i < labelim_1.length; i++) {
  if (choice==0){
  value = Math.floor(labelim_1[i]);
  } else if (choice==1){
  value = Math.floor(labelim_2_1[i]*16);
  } else if (choice==2){
  value = Math.floor(labelim_2_2[i]*16);
  } else {
  value = Math.floor(labelim_3[i]);
  }
  
  let r=value;
  let g=value;
  let b=value;
  
  data[i * 4] = r;
  data[i * 4 + 1] = g;
  data[i * 4 + 2] = b;
  data[i * 4 + 3] = 255;
}
pixels.data=data;
return pixels;
}

function GLBP_LocalPattern(pixels) {
//gradient local binary pattern
var data = pixels.data;
var grayImage = new Array(width * height);

for (let i = 0; i < data.length; i += 4) {
  const grayValue = Math.round(
	(data[i] + data[i + 1] + data[i + 2]) / 3
  );
  grayImage[i / 4] = grayValue;
}

var base2nums=[128,64,32,16,8,4,2,1];
var a1,a2,a3,a4,a5,a6,a7,a8,a9=0;
const labelim = new Array(width * height);
for (let i = 1; i < height - 1; i++) {
  for (let j = 1; j < width - 1; j++) {
	const center = grayImage[i * width + j];//a5
	a1=grayImage[(i - 1) * width + (j - 1)];
	a2=grayImage[(i - 1) * width + j];
	a3=grayImage[(i - 1) * width + (j + 1)];
	a4=grayImage[i * width + (j + 1)];
	a5=grayImage[(i + 1) * width + (j + 1)];
	a6=grayImage[(i + 1) * width + j];
	a7=grayImage[(i + 1) * width + (j - 1)];
	a8=grayImage[i * width + (j - 1)];
	// [a1,a2,a3,
	//	a8,center,a4,
	//	a7,a6,a5]
	var g_mean=Math.abs(a1-a5)+Math.abs(a3-a7)/2;

	label=(Math.abs(a1-center)>g_mean)*base2nums[0]+(Math.abs(a2-center)>g_mean)*base2nums[1]+(Math.abs(a3-center)>g_mean)*base2nums[2]+(Math.abs(a4-center)>g_mean)*base2nums[3]+(Math.abs(a5-center)>g_mean)*base2nums[4]+(Math.abs(a6-center)>g_mean)*base2nums[5]+(Math.abs(a7-center)>g_mean)*base2nums[6]+(Math.abs(a8-center)>g_mean)*base2nums[7];
	labelim[i * width + j] = label;
  }
}

for (let i = 0; i < labelim.length; i++) {
  const value = labelim[i];
  data[i * 4] = value;
  data[i * 4 + 1] = value;
  data[i * 4 + 2] = value;
  data[i * 4 + 3] = 255;
}
pixels.data=data;
return pixels;
}

findMax = a => a.reduce((res,cur) => res < cur ? cur : res ,-Infinity);
findMin = a => a.reduce((res,cur) => res > cur ? cur : res ,Infinity);

function HOG_Descriptor(pixels) {
var data = pixels.data;
width = canvas.width;
height = canvas.height;

gray = new Uint8ClampedArray(data.length);
for(var i = 0; i < data.length; i += 4) {
var r = data[i],
	g = data[i + 1],
	b = data[i + 2],
	a = data[i + 3];

var luma = Math.floor(r * 299/1000 + g * 587/1000
  + b * 114/1000);
gray[i] = gray[i+1] = gray[i+2] = luma;
gray[i+3] = 255;
}

//var cellsize=15;
//var binsize=6;
var choice=Math.floor(InputFieldsAll[0].value);
var cellsize=Math.floor(InputFieldsAll[1].value);
var binsize=Math.floor(InputFieldsAll[2].value);

len_1=data.length/4;
GradX_array = new Array(len_1);
GradY_array = new Array(len_1);
Mag_array = new Array(len_1);
Orient_array = new Array(len_1);
HOG_im = new Uint8ClampedArray(len_1);

var x1=0;
var y1=0;
var index=0;
var out=0;
for(var i = 0; i < gray.length; i += 4) {
index=i/4;
x1=index%width;
y1=Math.floor(index/width);

x_m1=x1-1;
y_m1=y1-1;
x_p1=x1+1;
y_p1=y1+1;
if (x_m1<0){x_m1=0}
if (y_m1<0){y_m1=0}
if (x_p1>=width){x_p1=width-1}
if (y_p1>=height){y_p1=height-1}

var prevX=gray[(y1*width+x_m1)*4];
var nextX=gray[(y1*width+x_p1)*4];
var prevY=gray[(y_m1*width+x1)*4];
var nextY=gray[(y_p1*width+x1)*4];

// kernel [-1, 0, 1]
conv_x = -prevX + nextX;
conv_y = -prevY + nextY;

grad1=Math.sqrt(conv_x**2+conv_y**2);
orient1=Math.atan2(conv_y, conv_x);

GradX_array[index] = conv_x;
GradY_array[index] = conv_y;
Mag_array[index] = grad1;
Orient_array[index] = orient1;

if(choice==0){out=Math.floor((255+GradX_array[index])/2)}
if(choice==1){out=Math.floor((255+GradY_array[index])/2)}
if(choice==2){out=Math.floor(Mag_array[index])}
if(choice==3){
orient1=Orient_array[index];
out = Math.abs(orient1);
out *= (180 / Math.PI);
if (out < 0) {
  out += 180;
}
out *= 255 / 180;
}
if(choice==4){
//out=0;
out=Math.floor(gray[i]/2);
}

data[i] = data[i+1] = data[i+2] = out;
}

histograms=extractHistograms(Mag_array,Orient_array,cellsize,binsize);
//histbin=extractHOGFromHistograms(histograms);

//mn=findMin(histograms.flat(Infinity));
//mx=findMax(histograms.flat(Infinity));

if(choice==4){
pixels.data=data;
ctx.putImageData(pixels, 0, 0);

ctx.lineWidth = 1;
ctx.strokeStyle = "rgb(128, 255, 128)";//"green";

var hhigh = histograms.length ;
var hwide = histograms[0].length ;

for (var y = 0; y < hhigh; y += 1) {
for (var x = 0; x < hwide; x += 1) {
  var hbin1 = histograms[y][x];
  for (var i = 0; i < binsize; i += 1){
  
  magval=(hbin1[i]-currentMin)/(currentMax-currentMin);
  //angle=i*(180/binsize);
  radians=i*(Math.PI/binsize)+(Math.PI/2);
  dx=(cellsize/2)*magval*Math.cos(radians);
  dy=(cellsize/2)*magval*Math.sin(radians);
  centerx=x*cellsize+Math.floor(cellsize/2);
  centery=y*cellsize+Math.floor(cellsize/2);
  startx=Math.floor(centerx-dx);
  starty=Math.floor(centery-dy);
  endx=Math.floor(centerx+dx);
  endy=Math.floor(centery+dy);
  
ctx.beginPath();
ctx.moveTo( startx, starty );
ctx.lineTo( endx, endy );
ctx.stroke();
  }
  }
  }
  
pixels = ctx.getImageData(0, 0, width, height);
currentMin=1e5;
currentMax=0;

}

if(choice!=4){
pixels.data=data;
}
return pixels;
}

function extractHistograms(Mag_array,Orient_array,cellSize,binsize) {
  var cellsWide = Math.floor(width / cellSize);
  var cellsHigh = Math.floor(height / cellSize);
  var histograms = new Array(cellsHigh);
  for (var i = 0; i < cellsHigh; i++) {
    histograms[i] = new Array(cellsWide);
    for (var j = 0; j < cellsWide; j++) {
      histograms[i][j] = getHistogram(Mag_array,Orient_array, j * cellSize, i * cellSize,
                                      cellSize, binsize);
    }
  }
  return histograms;
}

var currentMin=1e5;
var currentMax=0;

function getHistogram(Mag_array,Orient_array, x, y, size, binsize) {
  var histogram = zeros(binsize);
  for (var i = 0; i < size; i++) {
    for (var j = 0; j < size; j++) {
	  var flatpos=(y + i)*width+x + j;
      var bin = binFor(Orient_array[flatpos], binsize);
	  var magval=Mag_array[flatpos];
      histogram[bin] += magval;
    }
  }
  for(var i = 0; i < binsize; i++){
  histogram[i]/=(size*size*256);
  if(histogram[i]<currentMin) currentMin=histogram[i];
  if(histogram[i]>currentMax) currentMax=histogram[i];
  }
  return histogram;
}

function binFor(radians, binsize) {
  var angle = radians * (180 / Math.PI);
  if (angle < 0) {
    angle += 180;
  }
  // center the first bin around 0
  angle += 90 / binsize;
  angle %= 180;
  var bin = Math.floor(angle / 180 * binsize);
  return bin;
}

function zeros(size) {
  var array = new Array(size);
  for (var i = 0; i < size; i++) {
    array[i] = 0;
  }
  return array;
}

function L2_normalize(vector) {
    var sum = 0;
	var epsilon = 0.00001;
    for (var i = 0; i < vector.length; i++) {
      sum += Math.pow(vector[i], 2);
    }
    var denom = Math.sqrt(sum + epsilon);
    for (var i = 0; i < vector.length; i++) {
      vector[i] /= denom;
    }
  }
  
function extractHOGFromHistograms(histograms) {
  var blockSize = 2;
  var blockStride = (blockSize / 2);

  var blocks = [];
  var blocksHigh = histograms.length - blockSize + 1;
  var blocksWide = histograms[0].length - blockSize + 1;

  for (var y = 0; y < blocksHigh; y += blockStride) {
    for (var x = 0; x < blocksWide; x += blockStride) {
      var block = getBlock(histograms, x, y, blockSize);
      L2_normalize(block);
      blocks.push(block);
    }
  }
  return Array.prototype.concat.apply([], blocks);
}

function getBlock(matrix, x, y, length) {
  var square = [];
  for (var i = y; i < y + length; i++) {
    for (var j = x; j < x + length; j++) {
      square.push(matrix[i][j]);
    }
  }
  return Array.prototype.concat.apply([], square);
}

function Harris_Descriptor(pixels) {
var data = pixels.data;
width = canvas.width;
height = canvas.height;

kernel_x = [1, 0, -1, 2, 0, -2, 1, 0, -1];//sobel x
kernel_y = [1, 2, 1, 0, 0, 0, -1, -2, -1];//sobel y

gray = new Uint8ClampedArray(data.length);
tdata1 = new Uint8ClampedArray(data.length/4);
for(var i = 0; i < data.length; i += 4) {
	//var avg = Math.round((data[i] + data[i+1] + data[i+2]) / 3);
	var avg = Math.floor(data[i] * 0.299 + data[i+1] * 0.587
  + data[i+2] * 0.114);
	gray[i] = gray[i+1] = gray[i+2] = avg;
	gray[i+3] = 0;
	tdata1[i/4]=avg;
}


//var choice=Math.floor(InputFieldsAll[0].value);

len_1=data.length/4;
GradX_array = new Array(len_1);
GradY_array = new Array(len_1);
GradXY_array = new Array(len_1);
r_array = new Array(len_1);
result = new Array(len_1);

Orient_array = new Uint8ClampedArray(data.length/4);

var x1=0;
var y1=0;
var index=0;
var out=0;
for(var i = 0; i < gray.length; i += 4) {
index=i/4;
x1=index%width;
y1=Math.floor(index/width);

x_m1=x1-1;
y_m1=y1-1;
x_p1=x1+1;
y_p1=y1+1;
if (x_m1<0){x_m1=0}
if (y_m1<0){y_m1=0}
if (x_p1>=width){x_p1=width-1}
if (y_p1>=height){y_p1=height-1}

var box=[
gray[(y_m1*width+x_m1)*4],gray[(y_m1*width+x1)*4],gray[(y_m1*width+x_p1)*4],
gray[(y1*width+x_m1)*4],gray[i],gray[(y1*width+x_p1)*4],
gray[(y_p1*width+x_m1)*4],gray[(y_p1*width+x1)*4],gray[(y_p1*width+x_p1)*4],
];

var conv_x = (kernel_x[0] * box[0]) + (kernel_x[1] * box[1]) + (kernel_x[2] * box[2])
	+ (kernel_x[3] * box[3]) + (kernel_x[4] * box[4]) + (kernel_x[5] * box[5])
	+ (kernel_x[6] * box[6]) + (kernel_x[7] * box[7]) + (kernel_x[8] * box[8]);
	
var conv_y = (kernel_y[0] * box[0]) + (kernel_y[1] * box[1]) + (kernel_y[2] * box[2])
	+ (kernel_y[3] * box[3]) + (kernel_y[4] * box[4]) + (kernel_y[5] * box[5])
	+ (kernel_y[6] * box[6]) + (kernel_y[7] * box[7]) + (kernel_y[8] * box[8]);

var v_x2=conv_x**2;
var v_y2=conv_y**2;
var v_xy=conv_x*conv_y;

GradX_array[index] =v_x2;
GradY_array[index] =v_y2;
GradXY_array[index] =v_xy;
}

kernel = [1.0/9,1.0/9,1.0/9,1.0/9,1.0/9,1.0/9,1.0/9,1.0/9,1.0/9];
GradX_array=apply2dfilter2(GradX_array,kernel);
GradY_array=apply2dfilter2(GradY_array,kernel);
GradXY_array=apply2dfilter2(GradXY_array,kernel);
var rmax = 0;
for(var i = 0; i < GradX_array.length; i += 4) {


}

//data[i] = data[i+1] = data[i+2] = out;
pixels.data=data;
return pixels;
}

function apply2dfilter2(data,kernel){
gray=[...data];
var x1=0;
var y1=0;
var index=0;
for(var i = 0; i < gray.length; i += 1) {
index=i;
x1=index%width;
y1=Math.floor(index/width);

x_m1=x1-1;
y_m1=y1-1;
x_p1=x1+1;
y_p1=y1+1;
if (x_m1<0){x_m1=0}
if (y_m1<0){y_m1=0}
if (x_p1>=width){x_p1=width-1}
if (y_p1>=height){y_p1=height-1}

var box=[
gray[(y_m1*width+x_m1)],gray[(y_m1*width+x1)],gray[(y_m1*width+x_p1)],
gray[(y1*width+x_m1)],gray[i],gray[(y1*width+x_p1)],
gray[(y_p1*width+x_m1)],gray[(y_p1*width+x1)],gray[(y_p1*width+x_p1)],
];

var conv = (kernel[0] * box[0]) + (kernel[1] * box[1]) + (kernel[2] * box[2])
	+ (kernel[3] * box[3]) + (kernel[4] * box[4]) + (kernel[5] * box[5])
	+ (kernel[6] * box[6]) + (kernel[7] * box[7]) + (kernel[8] * box[8]);

grad1=Math.floor(conv);
//if (grad1<30){out=0} else{out=255}
data[i] = grad1;
}
return data;
}

//BRIEF_Descriptor
</script>

</body>

</html>
